# 스파게티 코드

대부분의 개발자들은 처음 개발을 시작할 때 들어본 말 가운데 스파게티 코드라는 것이 있을 것입니다. 복잡한 스파게티 코드를 읽고 정리하는 것은 스파게티 면발을 하나씩 정리하는 것 보다 훨씬 더 어려운 일이라는 것을 공감할 것입니다. 이미 스파게티가 되어버리면 유지보수가 어려워지고 그에 따라 많은 버그를 만들어 내는 것은 누구나 다 공감하는 사실입니다.

## 원인과 유형

유사한 말로 라자냐 코드 라는 말도 있는데 이는 OOP에서 지나치게 많은 상속 구조를 가지고 있어 복잡도가 증가했을 때를 비꼬는 말입니다. 스파게티 코드란 당장 내가 봤을 때 그 흐름을 따라가기 힘든 코드라고 정의해버릴 수도 있을 것 같습니다.
하지만 원인을 알아야 그것에 제대로 대처할 수 있듯이 스파게티 코드가 무엇인지 알아야 그리 하지 않을 수 있을 것입니다.

### 복잡한 제어문

cyclomatic complexity를 이야기 하는 이유가 여기에 있다고 생각합니다. 코드의 branch가 많아지면 읽어 나가기 매우 곤란하게 됩니다. 함수 안에서 if문이 단 하나도 존재하지 않는다면 그 코드를 읽는 머리는 매우 편안할 것입니다. 통상 복잡한 제어문은 단지 제어문 만으로 이루어지지는 않습니다.

### 많은 변수

변수는 두가지 스타일로 사용되는것 같습니다. 하나는 가지는 값이 제어에 영향을 주는 경우이고 다른 하나는 단지 값을 저장하는 용도일 것입니다. 스파게티 코드에 영향을 주는 경우는 주로 첫번째 경우인 값이 제어에 영향을 주는 경우일 것입니다. 값이 제어에 영향을 준다는 것은 그 변수를 이용해서 if, switch, for등을 사용하는 경우 일 것입니다. 이 경우 그 변수의 값에 따라서 제어가 바뀌게 되는데 코드를 읽을 때 값을 계속 기억하고 있어야 하는 문제가 있습니다. 대부분의 경우 제어에 이용되는 변수가 많으면 만을 수록 코드의 흐름을 따라가기 힘듭니다.

### 잘못된 상속

OOP에서 두 코드간의 커플링이 가장 심한 경우는 상속이 이루어진 경우입니다. 복잡한 상속관계를 가지는 클래스의 코드는 읽을 때 현재 코드와 슈퍼클래스의 코드를 오가면서 읽어야 합니다. 오버라이드 된 함수, 혹은 그렇지 않은 함수를 분리해서 생각하면서 읽어야 하고 어떤 함수는 직접 호출하기도 하지만 어떤 함수는 호출되기도 합니다. 상속이 가지는 기본적인 속성 자체만으로도 충분히 코드 읽기가 힘들어지는데, 여기에 잘못된 상속이 들어와버리면 정말 어려운 코드가 됩니다.

잘못된 상속의 경우는 매우 다양하게 발생하지만 예를 들어 feature envy에 기반한 경우를 이야기해보면 다음과 같은 상황이 있습니다. feature envy라 함은, 클래스 본연의 임무 이외에 기능이 불필요하게 해당 클래스에 들어간 경우인데 이것이 상속과 만나면서 복잡한 상황을 연출합니다. 자신의 class와 아무런 상관없는 동작을 하는데 super class의 도움을 받지 않고는 불가능한 경우가 발생합니다.

### 추상화 단계 부재

코드는 현 위치에서 동일한 추상화 단계를 사용해야 읽기가 쉽습니다. 올바른 추상화를 통해 코드의 결합도를 낮추는 동시에 응집도를 높일 수 있습니다.
