# Class

기본적으로 구조체와 개념적 컨셉이 거의 유사합니다. 구조체와 클래스는 프로그래머가 데이터를 용도에 맞게 묶어 표현하고자 할 때 용이합니다. 구조체와 클래스는 프로퍼티와 메소드를 사용하여 구조화된 데이터와 기능을 가질 수 있습니다. 하나의 새로운 사용자 정의 데이터 타입을 만들어 주는 것 입니다. 다만 중요한 차이는, **구조체의 인스턴스는 값 타입이고 클래스의 인스턴스는 참조 타입이라는 것** 입니다.

아래와 같이 클래스를 정의할 수 있습니다.

```swift
class Person {
    var height: Float = 0.0
    var weight: Float = 0.0
}
```

구조체와는 다르게 클래스의 인스턴스는 참조타입 이므로 상수로 선언해도 내부 프로퍼티 값을 변경할 수 있습니다.

```swift
var personA: Person = Person()
personA.height = 123.4
personA.weight = 123.4

let personB: Person = Person()
personB.height = 123.4
personB.weight = 123.4
```

## Struct와 Class

### 공통점

- 값을 저장하기 위해 프로퍼티를 정의할 수 있습니다.

- 기능 수행을 위해 메소드를 정의할 수 있습니다.

- 내부 프로퍼티에 접근하도록 서브스크립트를 정의할 수 있습니다.

- 초기화될 때의 상태를 지정하기 위해 initializer를 정의할 수 있습니다.

- extension을 통해 새로운 기능 추가를 확장할 수 있습니다.

- 특정 기능 수행을 위해 특정 프로토콜을 준수할 수 있습니다.

### 차이점

- 구조체의 인스턴스는 값 타입이고 클래스의 인스턴스는 참조 타입입니다.

- 구조체는 상속 불가능하지만 클래스는 상속 가능합니다.

- deinitializer는 클래스의 인스턴스에만 활용할 수 있습니다.

- 타입캐스팅은 클래스의 인스턴스에만 허용됩니다.

### 선택적 사용

값 타입과 참조 타입에 대한 내용은 [여기](./value_vs_reference.md)에서 제사한 확인이 가능합니다.

애플은 가이드 라인에서 다음 조건 중 하나 이상에 해당된다면 구조체 사용을 권장합니다.

- 연관된 간단한 값의 집합을 캡슐화 하는 것만이 목적일 때

- 캡슐화된 값이 참조되는 것보다 복사되는 것이 합당할 때

- 구조체에 저장된 프로퍼티가 값 타입이며 참조되는 것보다 복사되는 것이 합당할 때

- 다른 타입으로부터 상속받거나 자신이 상속될 필요가 없을 때

또한 멀티스레딩 환경에서 구조체의 사용이 권장되고는 합니다. 레퍼런스 타입보다 값 타입을 사용하는 가장 주된 목적은 코드를 이해하기 쉽다는 것입니다. 각 인스턴스가 독립된 데이터 사본을 가지고 있다는 것은, 보이지 않는 곳에서 해당 데이터가 임의로 변경되지 않음을 보장할 수 있다는 것입니다. 특히 이는 멀티스레드 환경에서 다른 스레드가 예기치 못한 시점에 데이터를 변경해놓을 수 있는 것을 방지합니다. (보통 이런 류의 문제는 디버깅이 극히 어렵습니다.) 변경이 없으면 값타입이나 참조타입은 기본적으로 동일합니다. 값타입은 동기화 없이 스레드 간에 데이터를 전달할 수 있습니다. 따라서 안정성을 높이는 관점에서 바라볼 때 이런 모델은 코드를 보다 더 예측가능하게 만들어 줄 것입니다.

그러나 클래스 사용이 권장되는 상황 역시 분명 존재합니다. 아래는 그 예시입니다.

```swift
var s: S? {
    didSet {
        print("didSet Struct")
    }
}


var c: C? {
    didSet {
        print("didSet Class")
    }
}

s = S()
c = C()

s?.num = 10
c?.num = 10
```

위 코드에 대한 print 결과는 아래와 같습니다.

```
didSet Struct
didSet Class
didSet Struct
```

Class인 경우에는 Class의 인스턴스 변수 값이 변경되어도 didSet이 호출되지 않습니다.

반면에 Struct의 경우에는 인스턴스 변수가 변경되어도 didSet이 호출 됩니다.

struct의 didSet 구문안에서 struct 내부값을 변경하는 로직을 구현하면 무한루프를 만날 수 있습니다. 때문에 이러한 상황에서는 class의 사용이 권장되고는 합니다.

### Reference:

- http://blog.yagom.net/530
